#!/usr/bin/env node

/**
 * Module dependencies.
 */

var Command = require('commander').Command;
var exists = require('fs').existsSync;
var resolve = require('path').resolve;
var dirname = require('path').dirname;
var mkdirp = require('mkdirp').sync;
var Logger = require('stream-log');
var stat = require('fs').statSync;
var stdin = require('get-stdin');
var Watch = require('duo-watch');
var join = require('path').join;
var spawn = require('win-fork');
var pkg = require('../package');
var main = require('duo-main');
var Batch = require('batch');
var stdout = process.stdout;
var cwd = process.cwd();
var Duo = require('..');

/**
 * Regexps
 */

var rmanifest = /component\.json$/;

/**
 * Logger
 */

var logger = new Logger(process.stderr)
  .type('building', '36m')
  .type('built', '36m')
  .type('installing', '36m')
  .type('installed', '36m')
  .type('finding', '36m')
  .type('found', '36m');

/**
 * Error
 */

logger.type('error', '31m', function(){
  logger.end();
  process.exit(1);
});

/**
 * Program
 */

var program = new Command('duo')
  .version(pkg.version)
  .usage('[options] command|[file, ...] [out]')
  .option('-c, --concurrency <n>', 'set concurrency, defaulted to 50', 50)
  .option('-d, --development', 'include development dependencies.', false)
  .option('-g, --global <name>', 'expose entry as a global <name>', null)
  .option('-o, --output <dir>', 'set the output directory, defaulted to build/', null)
  .option('-q, --quiet', 'only print to stderr when there is an error', false)
  .option('-r, --root <dir>', 'root directory to build from.', null)
  .option('-t, --type <type>', 'set the entry type', null)
  .option('-u, --use <plugin>', 'use transform plugin', null)
  .option('-v, --verbose', 'show as much logs as possible', false)
  .option('-w, --watch', 'watch for changes and rebuild', false)
  .parse(process.argv);

/**
 * Help
 */

program.on('--help', function(){
  console.log('  Usage:');
  console.log();
  console.log('  # build in.js to out.js');
  console.log('  $ duo in.js > out.js');
  console.log();
  console.log('  # build in.css to out.css');
  console.log('  $ duo in.css > out.css');
  console.log();
  console.log('  # build all files to duo.assets() (default: build/)');
  console.log('  $ duo *.{js,css}');
  console.log();
  console.log('  # build all files to the out/ folder');
  console.log('  $ duo *.{js,css} out');
  console.log();
  console.log('  # build from stdin and output out.css');
  console.log('  $ duo < in.css > out.css');
  console.log();
  console.log('  Commands:');
  console.log();
  console.log('    ls           list all dependencies.');
  console.log('    duplicates   show all duplicates.');
  console.log();
  process.exit(0);
});

/**
 * Command
 */

var command = program.args[0];

/**
 * $PATH
 */

var paths = [__dirname].concat(process.env.PATH.split(':'));

/**
 * Bin
 */

var bin = ['duo', command].join('-');

/**
 * Quiet flag.
 */

var quiet = program.quiet;

/**
 * Watch flag
 */

var watch = program.watch;

/**
 * Root
 */

var root = findroot(program.root);

/**
 * Custom executable
 */

if (command && !isFile(command)) {
  var args = process.argv.slice(3);

  // find executable
  var exec = paths.reduce(function(binary, path){
    path = resolve(path, bin);
    return exists(path) && stat(path)
      ? path
      : binary;
  }, bin);

  // does not exist
  if (!exists(exec)) {
    logger.error(bin + '(1) does not exist');
    return;
  }

  // spawn
  args.unshift(exec);

  // proxy subcommands through gnode(1)
  var gnode = require.resolve('gnode');
  var bin = join(dirname(gnode), 'bin', 'gnode');
  args.unshift(bin);

  var proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
  proc.on('close', process.exit.bind(process));

  return;
}

/**
 * Actions
 */

if (command) build(program.args.filter(globs));
else if (!process.stdin.isTTY) input();
else program.help();

/**
 * Watch for any other changes
 */

watch && Watch(root).watch(build);

/**
 * Accept standard input
 */

function input() {
  stdin(function(src) {
    var duo = create(root).src(src, program.type);

    duo.run(function(err, str) {
      if (err) throw error(err);
      logger.end();
      stdout.write(str);
      process.exit(0);
    });
  });
}

/**
 * Build file(s)
 *
 * @param {Array|String} entries
 * @api private
 */

function build(entries) {
  entries = 'string' == typeof entries ? [entries] : entries;

  var batch = new Batch;
  var len = entries.length;
  var last = entries[len - 1];
  var push = batch.push.bind(batch);
  var out = !isFile(last) ? entries.pop() : false;

  // add the manifest mains
  entries = entries
    .concat(mains(entries))
    .filter(manifests);

  // no entries to build
  !entries.length && program.help();

  // write to standard out
  if (1 == entries.length) {
    var duo = create(entries[0]);
    duo.run(function(err, src) {
      if (err) return error(err);
      logger.end();
      stdout.write(src);
      !watch && process.exit(0);
    });
  }

  // console.log(entries, mains(entries));

  // write multiple files to
  // `out` or `duo.assets()`
  if (entries.length > 1) {
    var duos = entries
      // .concat(mains(entries))
      .map(multiple)
      .map(push);

    batch.end(function(err) {
      if (err) return error(err);
      logger.end();
      !watch && process.exit(0);
    });
  }

  // filter out manifests
  function manifests(entry) {
    return !rmanifest.test(entry);
  }

  // write multiple entries to
  // the directory `out`
  function multiple(entry) {
    return function(done) {
      var duo = create(entry);
      out && duo.assets(out);
      duo.write(done);
    }
  }
}

/**
 * Create a duo instance
 *
 * @param {entry} entry
 * @return {Duo}
 * @api private
 */

function create(entry) {
  var duo = Duo(root)
    .development(!! program.development)
    .concurrency(program.concurrency)
    .entry(resolve(entry));

  // global
  program.global && duo.global(program.global);

  // verbose
  if (program.verbose) {
    duo.on('resolving', log('finding'));
    duo.on('resolve', log('found'));
    duo.on('installing', log('installing'));
  }

  // output dir
  program.out && duo.assets(program.out);

  if (program.use) {
    program.use.trim().split(",").forEach(function (plugin) {
      var mod = resolve(root, "node_modules", plugin.trim());
      duo.use(require(mod)());
    });
  }

  // events
  if (!quiet) {
    duo.on('install', log('installed'));
    duo.on('running', log('building'));
    duo.on('run', log('built'));
  }

  return duo;
}

/**
 * Log an event
 *
 * @param {String} event
 * @return {Function}
 */

function log (event) {
  return function(pkg) {
    pkg = pkg.slug ? pkg.slug() : pkg;
    pkg = 'source.js' == pkg ? 'from stdin' : pkg;
    logger[event](pkg);
  }
}

/**
 * Get the mains from the manifest
 *
 * @param {Array} entries
 * @return {Array}
 * @api private
 */

function mains(entries) {
  var out = [];
  var obj;

  for (var i = 0, entry; entry = entries[i++];) {
    if (rmanifest.test(entry)) {
      obj = json(resolve(root, entry));
      out = out.concat(main(obj));
    }
  }

  return out;
}

/**
 * Error
 */

function error(err) {
  err = 'string' == typeof err ? new Error(err) : err;
  logger.error(err.stack);
  logger.end();
}

/**
 * Get the JSON
 *
 * @param {String} path
 * @return {Object}
 * @api private
 */

function json(path) {
  try {
    return require(path);
  } catch (e) {
    return {};
  }
}

/**
 * Find the root
 *
 * @param {String} root
 * @param {String}
 */

function findroot(root) {
  if (root) return resolve(cwd, root);
  var path = cwd;

  while (!exists(join(path, 'component.json')) && '/' != path) {
    path = dirname(path);
  }

  return '/' == path
    ? cwd
    : path;
}

/**
 * Filter out unexpanded globs
 *
 * @param {String} entry
 * @return {Boolean}
 * @api private
 */

function globs(path) {
  return !/\*/.test(path);
}

/**
 * Simple hueristic to check
 * if `path` is a file
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

function isFile(path) {
  return path && !! ~path.indexOf('.');
}
