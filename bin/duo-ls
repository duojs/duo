#!/usr/bin/env node

/**
 * Module dependencies.
 */

var logger = require('stream-log')(process.stderr);
var parallel = require('co-parallel');
var values = require('object-values');
var program = require('commander');
var util = require('../lib/util');
var chalk = require('chalk');
var archy = require('archy');
var path = require('path');
var Duo = require('..');
var co = require('co');
var hasError = false;

/**
 * Logger errors.
 */

logger.type('error', '31m', function () {
  hasError = true;
});

/**
 * End logger output after process exit.
 */

process.on('exit', function () {
  if (hasError) process.exit(1);
});

/**
 * Program.
 */

program
  .usage('[options] file...')
  .description('Output the dependency tree for entry files.')
  .option('-d, --development', 'include development dependencies', false)
  .option('-D, --depth <depth>', 'depth to traverse', Number, Infinity)
  .option('-f, --flat', 'output a machine-friendly list', false)
  .option('-R, --no-remotes', 'exclude remotes from output', true)
  .option('-r, --root <dir>', 'root directory to build from', null)
  .option('-s, --stale', 'uses current cache to print', false)
  .option('-t, --type <type>', 'set the entry type', null)
  .option('-u, --use <plugin>', 'use transform plugin(s)', util.collect, [])
  .parse(process.argv);

/**
 * Examples.
 */

program.on('--help', function () {
  console.log('  Examples:');
  console.log();
  console.log('    # list dependency tree for index.js');
  console.log('    $ duo ls index.js');
  console.log();
  console.log('    # list dependency tree for multiple files');
  console.log('    $ duo ls index.js index.css');
  console.log();
  console.log('    # list all dependencies up to 5 levels deep');
  console.log('    $ duo ls --depth 5 index.js');
  console.log();
  console.log('    # list only local dependencies for index.js');
  console.log('    $ duo ls --no-remotes index.js');
  console.log();
  process.exit(0);
});

/**
 * Depth flag.
 */

var max = program.depth;

/**
 * GitHub credentials.
 */

var auth = util.auth();

/**
 * Root.
 */

var root = util.findroot(program.root);

/**
 * Plugins.
 */

try {
  var plugins = util.plugins(root, program.use);
} catch (err) {
  error(err);
  return;
}

/**
 * Specific entries are required in order to run.
 */

if (!program.args.length) {
  return logger.error('you must provide at least 1 entry file to process');
}

/**
 * Run.
 */

co(function* () {
  var gens = program.args.map(function* (entry) {
    var duo = build(entry);
    var map;

    if (program.stale) {
      var cache = yield duo.getCache();
      map = yield cache.read();
    } else {
      map = yield duo.install();
    }

    return { entry: entry, map: map };
  });

  var results = yield parallel(gens);

  if (!program.flat) console.log();

  results.forEach(function (result) {
    var ls = list(result.map, 0, {
      label: chalk.bold.underline(result.entry),
      name: result.entry,
      nodes: []
    });

    if (program.flat) {
      console.log(flatten(ls));
    } else {
      console.log(archy(ls, '  '));
    }
  });
})();

/**
 * List using `map` and `depth`.
 *
 * @param {Object} map
 * @param {Number} depth
 * @param {Object} node
 * @return {Array}
 */

function list(map, depth, node) {
  var deps = values(map[node.name].deps);

  deps.forEach(function (dep) {
    if (depth === max) return;

    var child = {
      label: pretty(dep),
      name: dep,
      nodes: []
    };

    var parts = dep.split(path.sep);
    if (!program.remotes && parts[0] === 'components') return;

    // LAME: add if not added
    if (!has(node.nodes, child)) {
      node.nodes.push(child);
      list(map, depth + 1, child);
    }
  });

  return node;
}

/**
 * Color the given `dep`
 *
 * @param {String} dep
 * @return {String}
 */

function pretty(dep) {
  var parts = dep.split(path.sep);
  return parts[0] === 'components' ? remote(dep) : local(dep);
}

/**
 * Colors the given local dep.
 *
 * @param {String} dep
 * @return {String}
 */

function local(dep) {
  return chalk.bold(dep);
}

/**
 * Colors the given remote dep.
 *
 * @param {String} dep
 * @return {String}
 */

function remote(dep) {
  var parts = dep.split(path.sep)[1].split('@');
  var name = parts[0];
  var version = parts[1];

  return [ chalk.cyan(name), chalk.grey(version) ].join(' ');
}

/**
 * Check if `nodes` has `node`.
 *
 * @param {Array} nodes
 * @param {Object} node
 * @return {Boolean}
 */

function has(nodes, node) {
  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i].name === node.name) return true;
  }
  return false;
}

/**
 * Create a duo instance.
 *
 * @param {entry} entry
 * @return {Duo}
 */

function build(entry) {
  return new Duo(root)
    .copy(program.copy)
    .token(auth.password)
    .use(plugins)
    .entry(entry);
}

/**
 * Error.
 */

function error(err) {
  err = typeof err === 'string' ? new Error(err) : err;
  if (err instanceof SyntaxError && err.fileName) {
    var msg = err.message;
    var file = path.relative(process.cwd(), err.fileName);
    logger.error('Syntax error:', msg, 'in:', file);
  } else {
    logger.error(err.stack);
  }
}

/**
 * Output the archy object in a flat style.
 *
 * @param {Object} obj
 * @param {String} ret
 */

function flatten(node, list) {
  if (!list) list = [];

  list.push(node.name);
  node.nodes.forEach(function (node) {
    flatten(node, list);
  });

  return list.join('\n');
}
